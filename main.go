package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/google/go-github/v71/github"
	"github.com/hasura/go-graphql-client"
	"github.com/shurcooL/githubv4"
	"github.com/urfave/cli/v2"
	"golang.org/x/oauth2"
)

const (
	VERSION           = "1.0.0"
	DEFAULT_CATEGORY  = "Others"
	TEXT_LENGTH_LIMIT = 200
	GITHUB_API_URL    = "https://api.github.com/graphql"
)

// Repository represents a GitHub repository
type Repository struct {
	NameWithOwner  string    `json:"name_with_owner"`
	Name           string    `json:"name"`
	Description    string    `json:"description"`
	Language       string    `json:"language"`
	URL            string    `json:"url"`
	StargazerCount int       `json:"stargazer_count"`
	ForkCount      int       `json:"fork_count"`
	PushedAt       time.Time `json:"pushed_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	StarredAt      time.Time `json:"starred_at"`
	IsPrivate      bool      `json:"is_private"`
	Topics         []string  `json:"topics"`
}

var descTemplate = `<!--lint disable awesome-contributing awesome-license awesome-list-item match-punctuation no-repeat-punctuation no-undefined-references awesome-spell-check-->
# Awesome Stars [![Awesome](https://awesome.re/badge.svg)](https://github.com/sindresorhus/awesome)

> A curated list of my GitHub stars! Generated by [starred](https://github.com/maguowei/starred).

## Contents
`

var licenseTemplate = `
## License

[![CC0](http://mirrors.creativecommons.org/presskit/buttons/88x31/svg/cc-zero.svg)]\
(https://creativecommons.org/publicdomain/zero/1.0/)

To the extent possible under law, [%s](https://github.com/%s)\
 has waived all copyright and related or neighboring rights to this work.
`

var htmlEscapeTable = map[string]string{
	">": "&gt;",
	"<": "&lt;",
}

func htmlEscape(text string) string {
	for k, v := range htmlEscapeTable {
		text = strings.ReplaceAll(text, k, v)
	}
	return text
}

type GitHubClient struct {
	graphqlClient *graphql.Client
	restClient    *github.Client
	ctx           context.Context
}

func NewGitHubClient(token string) *GitHubClient {
	ctx := context.Background()
	src := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	httpClient := oauth2.NewClient(ctx, src)
	graphqlClient := graphql.NewClient(GITHUB_API_URL, httpClient)
	restClient := github.NewClient(httpClient)

	return &GitHubClient{
		graphqlClient: graphqlClient,
		restClient:    restClient,
		ctx:           ctx,
	}
}

// CreateOrUpdateFile creates or updates a file in a GitHub repository
func (g *GitHubClient) CreateOrUpdateFile(owner, repo, path, message string, content []byte) error {
	// Try to get the repository
	_, _, err := g.restClient.Repositories.Get(g.ctx, owner, repo)
	if err != nil {
		// If the repository doesn't exist, create it
		if _, ok := err.(*github.ErrorResponse); ok &&
			err.(*github.ErrorResponse).Response.StatusCode == 404 {
			repoDesc := "A curated list of my GitHub stars!"
			private := false
			autoInit := false

			repoReq := &github.Repository{
				Name:        &repo,
				Description: &repoDesc,
				Private:     &private,
				AutoInit:    &autoInit,
			}

			_, _, err = g.restClient.Repositories.Create(g.ctx, "", repoReq)
			if err != nil {
				return fmt.Errorf("error creating repository: %w", err)
			}
		} else {
			return fmt.Errorf("error getting repository: %w", err)
		}
	}

	// Check if the file already exists
	fileContent, _, _, err := g.restClient.Repositories.GetContents(
		g.ctx, owner, repo, path,
		&github.RepositoryContentGetOptions{},
	)

	// Prepare the file options
	opts := &github.RepositoryContentFileOptions{
		Message: &message,
		Content: content,
	}

	if err == nil && fileContent != nil {
		// File exists, update it
		opts.SHA = fileContent.SHA
		_, _, err = g.restClient.Repositories.UpdateFile(g.ctx, owner, repo, path, opts)
		if err != nil {
			return fmt.Errorf("error updating file: %w", err)
		}
	} else {
		// File doesn't exist, create it
		_, _, err = g.restClient.Repositories.CreateFile(g.ctx, owner, repo, path, opts)
		if err != nil {
			return fmt.Errorf("error creating file: %w", err)
		}
	}

	return nil
}

type PageInfo struct {
	EndCursor   string
	HasNextPage bool
}

type TopicNode struct {
	Topic struct {
		Name           string
		StargazerCount int
	}
}

type LanguageNode struct {
	Node struct {
		ID   string
		Name string
	}
}

type RepoNode struct {
	Name           string
	NameWithOwner  string
	Description    string
	URL            string
	StargazerCount int
	ForkCount      int
	IsPrivate      bool
	PushedAt       time.Time
	UpdatedAt      time.Time
	Languages      struct {
		Edges []LanguageNode
	} `graphql:"languages(first: 1, orderBy: {field: SIZE, direction: DESC})"`
	RepositoryTopics struct {
		Nodes []TopicNode
	} `graphql:"repositoryTopics(first: 100)"`
}

type StarredEdge struct {
	StarredAt time.Time
	Node      RepoNode
}

type StarredReposQuery struct {
	User struct {
		StarredRepositories struct {
			TotalCount int
			Edges      []StarredEdge
			PageInfo   PageInfo
		} `graphql:"starredRepositories(first: $first, after: $after, orderBy: {direction: DESC, field: STARRED_AT})"`
	} `graphql:"user(login: $username)"`
}

func (g *GitHubClient) GetStarredRepositories(
	username string,
	after *string,
	topicStargazerCountLimit int,
) ([]Repository, *string, bool, error) {
	variables := map[string]interface{}{
		"username": githubv4.String(username),
		"first":    githubv4.Int(100),
		"after":    (*githubv4.String)(after),
	}

	var query StarredReposQuery
	err := g.graphqlClient.Query(g.ctx, &query, variables)
	if err != nil {
		return nil, nil, false, fmt.Errorf("error fetching starred repositories: %w", err)
	}

	var repos []Repository
	for _, edge := range query.User.StarredRepositories.Edges {
		node := edge.Node
		var language string
		if len(node.Languages.Edges) > 0 {
			language = node.Languages.Edges[0].Node.Name
		}

		var topics []string
		for _, topic := range node.RepositoryTopics.Nodes {
			if topic.Topic.StargazerCount > topicStargazerCountLimit {
				topics = append(topics, topic.Topic.Name)
			}
		}

		repos = append(repos, Repository{
			NameWithOwner:  node.NameWithOwner,
			Name:           node.Name,
			Description:    node.Description,
			Language:       language,
			URL:            node.URL,
			StargazerCount: node.StargazerCount,
			ForkCount:      node.ForkCount,
			PushedAt:       node.PushedAt,
			UpdatedAt:      node.UpdatedAt,
			StarredAt:      edge.StarredAt,
			IsPrivate:      node.IsPrivate,
			Topics:         topics,
		})
	}

	var nextCursor *string
	if query.User.StarredRepositories.PageInfo.HasNextPage {
		cursor := query.User.StarredRepositories.PageInfo.EndCursor
		nextCursor = &cursor
	}

	return repos, nextCursor, query.User.StarredRepositories.PageInfo.HasNextPage, nil
}

// isRetryableError checks if an error is transient and should be retried
func isRetryableError(err error) bool {
	if err == nil {
		return false
	}
	errStr := err.Error()
	retryablePatterns := []string{
		"502 Bad Gateway",
		"503 Service Unavailable",
		"504 Gateway Timeout",
		"stream error",
		"CANCEL",
		"json_decode_error",
		"connection reset",
		"EOF",
		"timeout",
		"You have exceeded a secondary rate limit",
	}
	for _, pattern := range retryablePatterns {
		if strings.Contains(errStr, pattern) {
			return true
		}
	}
	return false
}

func (g *GitHubClient) GetAllStarredRepositories(
	username string,
	topicStargazerCountLimit int,
) ([]Repository, error) {
	var allRepos []Repository
	var cursor *string
	hasNextPage := true
	count := 0

	fmt.Printf("Fetching starred repositories for %s...\n", username)
	start := time.Now()
	maxTotalWaitTime := 30 * time.Minute
	maxRetries := 5

	for hasNextPage {
		if cursor != nil {
			fmt.Printf("Using after cursor: %s\n", *cursor)
		}

		var repos []Repository
		var nextCursor *string
		var hasNext bool
		var err error

		// Retry loop with exponential backoff
		for attempt := 0; attempt < maxRetries; attempt++ {
			repos, nextCursor, hasNext, err = g.GetStarredRepositories(
				username,
				cursor,
				topicStargazerCountLimit,
			)
			if err == nil {
				break
			}

			timeSpent := time.Since(start)
			if timeSpent > maxTotalWaitTime {
				return nil, fmt.Errorf("max wait time exceeded: %w", err)
			}

			if !isRetryableError(err) {
				return nil, err
			}

			// Exponential backoff: 5s, 10s, 20s, 40s, 80s
			backoff := time.Duration(5*(1<<attempt)) * time.Second
			fmt.Printf("Transient error (attempt %d/%d): %v\n", attempt+1, maxRetries, err)
			fmt.Printf("Retrying in %v...\n", backoff)
			time.Sleep(backoff)
		}

		if err != nil {
			return nil, fmt.Errorf("max retries exceeded: %w", err)
		}

		allRepos = append(allRepos, repos...)
		count += len(repos)
		fmt.Printf("Fetched %d repositories so far....\n", count)

		cursor = nextCursor
		hasNextPage = hasNext
		time.Sleep(3 * time.Second) // Avoid hitting the rate limit
	}

	return allRepos, nil
}

func generateREADME(
	username string,
	stars []Repository,
	doSort bool,
	useTopic bool,
	includePrivate bool,
) (string, error) {
	var buf bytes.Buffer
	writer := io.Writer(&buf)

	fmt.Fprintln(writer, descTemplate)

	repoDict := make(map[string][][]string)

	for _, star := range stars {
		if star.IsPrivate && !includePrivate {
			continue
		}

		description := ""
		if star.Description != "" {
			description = htmlEscape(star.Description)
			description = strings.ReplaceAll(description, "\n", "")
			description = strings.TrimSpace(description)
			if len(description) > TEXT_LENGTH_LIMIT {
				description = description[:TEXT_LENGTH_LIMIT]
			}
		}

		if useTopic {
			topics := star.Topics
			if len(topics) == 0 {
				topics = []string{strings.ToLower(DEFAULT_CATEGORY)}
			}

			for _, category := range topics {
				repoDict[category] = append(
					repoDict[category],
					[]string{star.NameWithOwner, star.URL, description},
				)
			}
		} else {
			category := star.Language
			if category == "" {
				category = DEFAULT_CATEGORY
			}

			repoDict[category] = append(repoDict[category], []string{star.NameWithOwner, star.URL, description})
		}
	}

	// Sort categories if requested
	var categories []string
	for category := range repoDict {
		categories = append(categories, category)
	}

	if doSort {
		sort.Strings(categories)
	}

	// Generate table of contents
	for _, category := range categories {
		categoryLink := strings.ToLower(strings.ReplaceAll(category, " ", "-"))
		fmt.Fprintf(writer, "- [%s](#%s)\n", category, categoryLink)
	}
	fmt.Fprintln(writer, "")

	// Generate content by category
	for _, category := range categories {
		escapedCategory := strings.ReplaceAll(category, "#", "# #")
		fmt.Fprintf(writer, "## %s \n\n", escapedCategory)

		for _, repo := range repoDict[category] {
			fmt.Fprintf(writer, "- [%s](%s) - %s\n", repo[0], repo[1], repo[2])
		}
		fmt.Fprintln(writer, "")
	}

	// Add license
	fmt.Fprintf(writer, licenseTemplate, username, username)

	return buf.String(), nil
}

func main() {
	app := &cli.App{
		Name:    "starred",
		Usage:   "Create your own Awesome List by GitHub stars!",
		Version: VERSION,
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:     "username",
				Aliases:  []string{"u"},
				Usage:    "GitHub username",
				Required: true,
				EnvVars:  []string{"USER"},
			},
			&cli.StringFlag{
				Name:     "token",
				Aliases:  []string{"t"},
				Usage:    "GitHub token",
				Required: true,
				EnvVars:  []string{"GITHUB_TOKEN"},
			},
			&cli.BoolFlag{
				Name:    "sort",
				Aliases: []string{"s"},
				Usage:   "sort by category[language/topic] name alphabetically",
			},
			&cli.BoolFlag{
				Name:  "topic",
				Usage: "category by topic, default is category by language",
			},
			&cli.IntFlag{
				Name:  "topic_limit",
				Usage: "topic stargazer_count gt number, set bigger to reduce topics number",
				Value: 500,
			},
			&cli.StringFlag{
				Name:    "repository",
				Aliases: []string{"r"},
				Usage:   "repository name",
				Value:   "",
			},
			&cli.StringFlag{
				Name:    "filename",
				Aliases: []string{"f"},
				Usage:   "file name",
				Value:   "README.md",
			},
			&cli.StringFlag{
				Name:    "message",
				Aliases: []string{"m"},
				Usage:   "commit message",
				Value:   "update awesome-stars, created by starred",
			},
			&cli.BoolFlag{
				Name:    "private",
				Aliases: []string{"p"},
				Usage:   "include private repos",
			},
			&cli.BoolFlag{
				Name:  "json",
				Usage: "output JSON instead of markdown",
			},
			&cli.StringFlag{
				Name:    "output",
				Aliases: []string{"o"},
				Usage:   "output file path (default: stdout)",
			},
		},
		Action: func(c *cli.Context) error {
			username := c.String("username")
			token := c.String("token")
			doSort := c.Bool("sort")
			useTopic := c.Bool("topic")
			repository := c.String("repository")
			filename := c.String("filename")
			message := c.String("message")
			includePrivate := c.Bool("private")
			topicLimit := c.Int("topic_limit")
			outputJSON := c.Bool("json")
			outputFile := c.String("output")

			client := NewGitHubClient(token)
			stars, err := client.GetAllStarredRepositories(username, topicLimit)
			if err != nil {
				fmt.Printf("Error: %s\n", err)
				return err
			}

			// Filter private repos if needed
			if !includePrivate {
				filtered := make([]Repository, 0, len(stars))
				for _, s := range stars {
					if !s.IsPrivate {
						filtered = append(filtered, s)
					}
				}
				stars = filtered
			}

			// JSON output mode - write to file if specified, otherwise print and exit
			if outputJSON {
				jsonData, err := json.MarshalIndent(stars, "", "  ")
				if err != nil {
					return fmt.Errorf("error marshaling JSON: %w", err)
				}
				if outputFile != "" {
					if err := os.WriteFile(outputFile, jsonData, 0644); err != nil {
						return fmt.Errorf("error writing file: %w", err)
					}
					fmt.Printf("Wrote %d repos to %s\n", len(stars), outputFile)
					// Continue to README generation if repository is specified
				} else {
					// No file specified, print to stdout and exit
					fmt.Println(string(jsonData))
					return nil
				}
			}

			readme, err := generateREADME(
				username,
				stars,
				doSort,
				useTopic,
				true, // already filtered above
			)
			if err != nil {
				fmt.Printf("Error generating README: %s\n", err)
				return err
			}

			if repository != "" {
				var buffer bytes.Buffer
				buffer.WriteString(readme)

				// Create or update repository file
				err = client.CreateOrUpdateFile(
					username,
					repository,
					filename,
					message,
					buffer.Bytes(),
				)
				if err != nil {
					fmt.Printf("Error: %s\n", err)
					return err
				}

				repoURL := fmt.Sprintf("https://github.com/%s/%s", username, repository)
				fmt.Printf("Created/updated repository: %s\n", repoURL)
			} else {
				fmt.Print(readme)
			}

			return nil
		},
	}

	err := app.Run(os.Args)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
